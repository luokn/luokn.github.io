[{"title":"sshfs-win教程","url":"/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/sshfs-win%E6%95%99%E7%A8%8B/","content":"\n安装 winfsp、sshfs-win\n winget install WinFsp.WinFspwinget install SSHFS-Win.SSHFS-Win\n\n挂载 SSHFS\n net.exe use Z: \\\\sshfs.kr\\root@&#123;ip&#125;!&#123;port&#125;\n\n\n可用 net.exe use Z: /delete 卸载磁盘\n\n\n\n","categories":["操作系统"],"tags":["操作系统","Windows","SSHFS"]},{"title":"Systemd教程","url":"/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/systemd%E6%95%99%E7%A8%8B/","content":"Systemd是 Linux 下一系列工具的集合，其涵盖了 Linux 的系统启动、服务监控、状态查询、日志归档、设备管理、电源管理与定时任务等功能，除此之外还支持通过特定设备事件与特定端口数据触发的 On-demand（按需）任务。\nSystemd这一名字源于Unix中的一个惯例：在 Unix 中常以“d”作为系统守护进程（英语：daemon，亦称后台进程）的后缀标识。\n一、Systemd 的起源1、System V 启动系统在Systemd出现之前，大多数 Linux 发行版使用的是一种源自 Unix 的System V风格的init守护进程，它通过运行级别（run level）来确定系统的运行状态，并根据运行级别运行特定的脚本来完成系统的初始化。\nSystem V 的服务脚本存放在/etc/init.d下，同时在/etc下还存在rc[0~6]等目录，这些目录下的可执行文件即为不同的运行级别需要启动或者禁止的服务，实际上这些目录下大多数情况下都是一些软链接，其真正的指向是/etc/init.d下的服务脚本。\n在 Linux 主要应用于服务器的时代，System V运行非常良好，它的概念简单清晰，但它的服务启动它主要依赖于 Shell 脚本，这就导致了它最大的缺陷：启动太慢。这是因为System V的服务都是通过 Shell 启动的，由于 System V 缺少依赖解析的机制，因此这是一个串行过程。这个缺陷在很少重启的服务器上并不明显，而在移动设备上就显得格外突出。为了更快地启动，人们开始改进init，于是开始出现了Upstart和Systemd。\n2、Systemd 的改进与System V风格 init 相比，Systemd采用了以下新技术：\n\n将service（服务）、target（运行模式，类似于System V的 run level）、mount、timer、snapshot、path、socket、swap等称为Unit。比如，一个auditd服务（就是auditd.service）就是一个Unit，一个multi-user.target运行模式也是一个Unit。\n采用Socket激活式与D-Bus激活式服务，以提高相互依赖的各服务的并行运行性能。\n用CGroups代替PID来追踪进程，因此即使是两次fork之后生成的守护进程也不会脱离Systemd的控制。\n用 Target 代替System V的 run level，比如Systemd的graphical.target相当于System V的RunLevel 5，multi-user.target相当于 System V 的RunLevel 3。\n\n\n内置journald 日志管理系统。\n内置resolved、timesyncd、networkd等组件。\n引入localectl、timedatectl、hostnamectl等新命令，系统配置更方便。\n\n截至目前，Systemd已经是是 Linux 发行版上最常见的init进程，Debian 系（Ubuntu、Linux Mint 等）、Red Hat 系（RHEL、Fedora、CentOS 等）、openSUSE、Arch Linux 都已经使用了Systemd。\n二、Systemd 架构Systemd 体系非常复杂，功能涉及到了 Linux 系统的方方面面。\n\n1、管理工具Systemd常见的 control 工具及功能如下：\n\n\n\n命令名称\n功能描述\n\n\n\nsystemctl\nSystemd的主命令，用于系统初始化配置和 Unit 管理\n\n\njournalctl\n日志管理\n\n\nhostnamectl\n主机名管理\n\n\nlocalectl\n区域与键盘布局管理\n\n\nloginctl\n登陆管理\n\n\ntimedatectl\n时间与日期管理\n\n\nnetworkctl\n网络管理\n\n\nbootctl\nEFI 固件与启动器管理\n\n\nresolvectl\n域名解析管理\n\n\nsystemd-analyze\nSystemd的启动分析工具\n\n\nsystemd-cgtop\nSystemd的CGroups资源分析工具\n\n\nsystemd-cat\nSystemd的 Unit 读取工具\n\n\nsystemd-mount\nSystemd的文件挂载工具\n\n\nsystemd-unmount\nSystemd的文件卸载工具\n\n\n2、守护进程Systemd常见的 daemon 进程及功能描述如下：\n\n\n\n进程名称\n功能描述\n\n\n\nsystemd\nsystemd内核启动后创建的第一个用户态进程，它的 PID&#x3D;1，它通过读取文件系统上的配置来启动服务与守护进程，它是 Linux 上所有进程的父进程\n\n\nsystemd-journald\nsystemd-journald是用于收集和存储日志数据的守护进程，它能够收集内核的日志与服务的标准输入输出并持久化存储\n\n\nsystemd-udevd\nsystemd-udevd合并了udev，它用于监听内核发出的设备通知并根据配置做出处理\n\n\nsystemd-logind\nsystemd-logind是用于用户的登陆管理的守护进程\n\n\nsystemd-networkd\nsystemd-networkd是用于网络管理的守护进程\n\n\nsystemd-resolved\nsystemd-resolved是用于域名解析的守护进程\n\n\n3、资源管理Systemd通过基本单元 Unit 来管理系统资源，可以认为每个系统资源就是一个 Unit，并使用一个 Unit 文件定义。在 Unit 文件中需要包含相应服务的描述、属性以及需要运行的命令，Systemd一共支持 12 种 Unit 类型，分别是：\n\n.automount：用于控制自动挂载文件系统，相当于System V的autofs服务。\n.device：对于/dev目录下的设备，主要用于定义设备之间的依赖关系。\n.mount：定义系统结构层次中的一个挂载点，可以替代过去的/etc/fstab配置文件。\n.path：用于监控指定目录或文件的变化，并触发其它 Unit 运行。\n.scope：这种 Unit 文件不是用户创建的，而是Systemd运行时产生的，描述一些系统服务的分组信息。\n.service：封装守护进程的启动、停止、重启和重载操作，是最常见的一种 Unit 文件。\n.slice：用于表示一个CGroups的树，通常用户不会自己创建这样的 Unit 文件。\n.snapshot：用于表示一个由systemctl snapshot命令创建的 Units 运行状态快照。\n.socket：监控来自于系统或网络的数据消息，用于实现基于数据自动触发服务启动。\n.swap：定义一个用户做虚拟内存的交换分区。\n.target：用于对 Unit 文件进行分组，引导其它 Unit 的执行。它还替代了System V运行级别的作用，并提供更灵活的基于特定设备事件的启动方式。\n.timer：用于配置在定时任务，可以替代crontab。\n\n4、目录结构Unit 文件按照Systemd约定，应该被放置指定的三个系统目录之一中。这三个目录是有优先级的，如下所示，越靠上的优先级越高。因此，在三个目录中有同名文件的时候，只有优先级最高的目录里的那个文件会被使用。\n\n/etc/systemd/system：系统或用户自定义的配置文件。\n/run/systemd/system：软件运行时生成的配置文件。\n/usr/lib/systemd/system：系统或第三方软件安装时添加的配置文件。\n\nSystemd默认从目录/etc/systemd/system/读取配置文件，但是里面存放的大部分都是指向/usr/lib/systemd/system/下配置文件的符号链接。\n三、Systemd 配置1、服务Systemd 的 Service 是 Systemd 的最基本的单元，用于配置程序启动配置与依赖。\n# /lib/systemd/system/nginx.service# Stop dance for nginx# =======================## ExecStop sends SIGSTOP (graceful stop) to the nginx process.# If, after 5s (--retry QUIT/5) nginx is still running, systemd takes control# and sends SIGTERM (fast shutdown) to the main process.# After another 5s (TimeoutStopSec=5), and if nginx is alive, systemd sends# SIGKILL to all the remaining processes in the process group (KillMode=mixed).## nginx signals reference doc:# http://nginx.org/en/docs/control.html#[Unit]Description=A high performance web server and a reverse proxy serverDocumentation=man:nginx(8)After=network.target nss-lookup.target[Service]Type=forkingPIDFile=/run/nginx.pidExecStartPre=/usr/sbin/nginx -t -q -g &#x27;daemon on; master_process on;&#x27;ExecStart=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27;ExecReload=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27; -s reloadExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pidTimeoutStopSec=5KillMode=mixed[Install]WantedBy=multi-user.target\n\n# /lib/systemd/system/ssh.service[Unit]Description=OpenBSD Secure Shell serverDocumentation=man:sshd(8) man:sshd_config(5)After=network.target auditd.serviceConditionPathExists=!/etc/ssh/sshd_not_to_be_run[Service]EnvironmentFile=-/etc/default/sshExecStartPre=/usr/sbin/sshd -tExecStart=/usr/sbin/sshd -D $SSHD_OPTSExecReload=/usr/sbin/sshd -tExecReload=/bin/kill -HUP $MAINPIDKillMode=processRestart=on-failureRestartPreventExitStatus=255Type=notifyRuntimeDirectory=sshdRuntimeDirectoryMode=0755[Install]WantedBy=multi-user.targetAlias=sshd.service\n\n2、设备3、挂载点4、定时器","categories":["操作系统"],"tags":["Linux","操作系统","systemd"]},{"title":"数据结构：哈希表","url":"/2021/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8/","content":"1. Hash 函数主要使用以下几个 Hash 函数\ntypedef unsigned int (*hash_fn_t)(void*);#define AP_HASH ((hash_fn_t) __ap_hash)#define RS_HASH ((hash_fn_t) __rs_hash)#define JS_HASH ((hash_fn_t) __js_hash)#define PJW_HASH ((hash_fn_t) __pjw_hash)#define ELF_HASH ((hash_fn_t) __elf_hash)#define DJB_HASH ((hash_fn_t) __djb_hash)#define SDBM_HASH ((hash_fn_t) __sdbm_hash)#define BKDR_HASH ((hash_fn_t) __bkdr_hash)#define CRC32_HASH ((hash_fn_t) __crc32_hash)#define CRC64_HASH ((hash_fn_t) __crc64_hash)\n\n定义如下：\nunsigned int __ap_hash(const char*);unsigned int __rs_hash(const char*);unsigned int __js_hash(const char*);unsigned int __pjw_hash(const char*);unsigned int __elf_hash(const char*);unsigned int __djb_hash(const char*);unsigned int __sdbm_hash(const char*);unsigned int __bkdr_hash(const char*);unsigned int __crc32_hash(const char*);unsigned int __crc64_hash(const char*);\n\n实现在hash.c中：\n#include &quot;hash.h&quot;#include &quot;crc32.h&quot;#include &quot;crc64.h&quot;unsigned int __ap_hash(const char* str) &#123;    unsigned int hash = 0;    int          i;    for (i = 0; *str; i++) &#123;        if ((i &amp; 1) == 0) &#123;            hash ^= ((hash &lt;&lt; 7) ^ (*str++) ^ (hash &gt;&gt; 3));        &#125; else &#123;            hash ^= (~((hash &lt;&lt; 11) ^ (*str++) ^ (hash &gt;&gt; 5)));        &#125;    &#125;    return hash;&#125;unsigned int __rs_hash(const char* str) &#123;    unsigned int hash = 0, a = 63689, b = 378551;    while (*str) &#123;        hash = hash * a + (*str++);        a *= b;    &#125;    return hash;&#125;unsigned int __js_hash(const char* str) &#123;    unsigned int hash = 1315423911;    while (*str) &#123;        hash ^= ((hash &lt;&lt; 5) + (*str++) + (hash &gt;&gt; 2));    &#125;    return hash;&#125;unsigned int __pjw_hash(const char* str) &#123;    unsigned int bits_in_unigned_int = (unsigned int) (sizeof(unsigned int) * 8);                         // 32    unsigned int three_quarters      = (unsigned int) ((bits_in_unigned_int * 3) / 4);                    // 24    unsigned int one_eighth          = (unsigned int) (bits_in_unigned_int / 8);                          // 4    unsigned int high_bits           = (unsigned int) (0xFFFFFFFF) &lt;&lt; (bits_in_unigned_int - one_eighth); // 0xFFFFFFF0    unsigned int hash                = 0;    unsigned int test                = 0;    while (*str) &#123;        hash = (hash &lt;&lt; one_eighth) + (*str++);        if ((test = hash &amp; high_bits) != 0) &#123;            hash = ((hash ^ (test &gt;&gt; three_quarters)) &amp; (~high_bits));        &#125;    &#125;    return hash;&#125;unsigned int __elf_hash(const char* str) &#123;    unsigned int hash = 0;    unsigned int x    = 0;    while (*str) &#123;        hash = (hash &lt;&lt; 4) + (*str++);        if ((x = hash &amp; 0xF0000000L) != 0) &#123;            hash ^= (x &gt;&gt; 24);            hash &amp;= ~x;        &#125;    &#125;    return hash;&#125;unsigned int __djb_hash(const char* str) &#123;    unsigned int hash = 5381;    while (*str) &#123;        hash += (hash &lt;&lt; 5) + (*str++);    &#125;    return hash;&#125;unsigned int __sdbm_hash(const char* str) &#123;    unsigned int hash = 0;    while (*str) &#123;        hash = (*str++) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;    &#125;    return hash;&#125;unsigned int __bkdr_hash(const char* str) &#123;    unsigned int hash = 0;    while (*str) &#123;        hash = hash * 31 + (*str++);    &#125;    return hash;&#125;unsigned int __crc32_hash(const char* str) &#123;    return strcrc32(str);&#125;unsigned int __crc64_hash(const char* str) &#123;    return strcrc64(str);&#125;\n\n2. HashMap 的实现声明在hashmap.h中\n#pragma once#include &quot;hash.h&quot;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#define HASHMAP_MIN_SIZE 0x10#define HASHMAP_MAX_SIZE 0x40000000typedef int (*equals_fn_t)(void*, void*);struct hashmap_entry;/* * Hashmap structure. */typedef struct hashmap &#123;                       // 56 Bytes    uint32_t               __size, __capacity; // 8 Bytes    struct hashmap_entry** __buckets;          // 8 Bytes    struct hashmap_entry*  __entries;          // 8 Bytes    struct hashmap_entry*  __current;          // 8 Bytes    struct hashmap_entry*  __freelist;         // 8 Bytes    hash_fn_t              __hash;             // 8 Bytes    equals_fn_t            __equals;           // 8 Bytes&#125; hashmap_t;#define hashmap_hash(MAP, KEY) ((MAP)-&gt;__hash(KEY))#define hashmap_equals(MAP, A, B) ((MAP)-&gt;__equals(A, B))int      hashmap_init(hashmap_t*, uint32_t, hash_fn_t, equals_fn_t);int      hashmap_destroy(hashmap_t*);int      hashmap_clear(hashmap_t*);int      hashmap_resize(hashmap_t*, uint32_t);uint32_t hashmap_size(hashmap_t*);uint32_t hashmap_capacity(hashmap_t*);uint32_t hashmap_maxload(hashmap_t*);int      hashmap_insert(hashmap_t*, void* key, void* value, bool update);int      hashmap_delete(hashmap_t*, void* key);int      hashmap_set(hashmap_t*, void* key, void* value);void*    hashmap_get(hashmap_t*, void* key, void* default_value);bool     hashmap_exists(hashmap_t*, void* key);/* * Hashmap pair */struct hashmap_pair &#123; // 16 Bytes    void* k;          // 8 Bytes    void* v;          // 8 Bytes&#125;;/* * Hashmap entry */struct hashmap_entry &#123;          // 32 Bytes    struct hashmap_pair   pair; // 16 Bytes, key and value pointer.    int32_t               uses; // 4 Bytes, uses(0 or 1).    uint32_t              hash; // 4 Bytes, hash value.    struct hashmap_entry* next; // 8 Bytes, next entry pointer.&#125;;/* * Hashmap iterator */struct hashmap_iterator &#123;    const struct hashmap_pair* pair;    hashmap_t*                 __map;    struct hashmap_entry*      __entry;    uint32_t                   __bucket_id;&#125;;bool hashmap_iterator_next(struct hashmap_iterator*);#define hashmap_iterator_init(MAP) \\    &#123; .pair = NULL, .__map = (MAP), .__entry = &amp;(MAP)-&gt;__entries[0], .__bucket_id = 0 &#125;#define hashmap_foreach(MAP, ITER) \\    for (struct hashmap_iterator ITER = hashmap_iterator_init(ITER); hashmap_iterator_next(&amp;ITER);)\n\n实现在hashmap.c\n#include &quot;hashmap.h&quot;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// HASH % 2^N#define hashmap_index_for(HASH, CAPACITY) ((HASH) &amp; ((CAPACITY) -1))// Load factor: 0.75#define hashmap_maxload_of(CAPACITY) (((CAPACITY) &gt;&gt; 1) | ((CAPACITY) &gt;&gt; 2))static uint32_t __hashmap_default_hash(void* key) &#123;    return (uintptr_t) key;&#125;static int __hashmap_default_equals(void* a, void* b) &#123;    return a == b ? 0 : -1;&#125;static void __hashmap_rebuild(hashmap_t* map, struct hashmap_entry** buckets, struct hashmap_entry* entries,                              uint32_t capacity) &#123;    struct hashmap_entry* new_entry = entries;    struct hashmap_entry* old_entry = map-&gt;__entries;    uint32_t              maxload   = hashmap_maxload_of(map-&gt;__capacity);    for (uint32_t i = 0; i &lt; maxload; i++, old_entry++) &#123;        if (old_entry-&gt;uses) &#123;            uint32_t              hash = old_entry-&gt;hash;            uint32_t              buck = hashmap_index_for(hash, capacity);            struct hashmap_entry *prev = NULL, *curr = buckets[buck];            while (curr &amp;&amp; curr-&gt;hash &lt; hash) &#123;                prev = curr;                curr = curr-&gt;next;            &#125;            new_entry-&gt;pair = old_entry-&gt;pair;            new_entry-&gt;uses = 1;            new_entry-&gt;hash = hash;            new_entry-&gt;next = curr;            if (prev)                prev-&gt;next = new_entry++;            else                buckets[buck] = new_entry++;        &#125;    &#125;&#125;static int __hashmap_resize(hashmap_t* map, uint32_t capacity) &#123;    uint32_t maxload = hashmap_maxload_of(capacity);    // Allocate memory for new buckets    struct hashmap_entry** buckets = (struct hashmap_entry**) malloc(capacity * sizeof(void*));    if (buckets == NULL) return -1;    // Allocate memory for new entries    struct hashmap_entry* entries = (struct hashmap_entry*) malloc(maxload * sizeof(struct hashmap_entry));    if (entries == NULL) return (free(buckets), -1);    // Set buckets and entries to 0    memset(buckets, 0, capacity * sizeof(void*));    memset(entries, 0, maxload * sizeof(struct hashmap_entry));    // Rebuild hashmap    __hashmap_rebuild(map, buckets, entries, capacity);    // Free old buckets and entries    free(map-&gt;__buckets);    free(map-&gt;__entries);    // Reset members    map-&gt;__capacity = capacity;    map-&gt;__buckets  = buckets;    map-&gt;__entries  = entries;    map-&gt;__current  = &amp;entries[map-&gt;__size];    map-&gt;__freelist = NULL;    return 0;&#125;static inline uint32_t __hashmap_capacity_for(uint32_t capacity) &#123;    capacity--;    capacity |= capacity &gt;&gt; 1;    capacity |= capacity &gt;&gt; 2;    capacity |= capacity &gt;&gt; 4;    capacity |= capacity &gt;&gt; 8;    capacity |= capacity &gt;&gt; 16;    capacity++;    return capacity;&#125;int hashmap_init(hashmap_t* map, uint32_t capacity, hash_fn_t hash, equals_fn_t equals) &#123;    // Check capacity.    if (capacity &gt; HASHMAP_MAX_SIZE) return -1;    // Clip capacity.    capacity = capacity &lt; HASHMAP_MIN_SIZE ? HASHMAP_MIN_SIZE : __hashmap_capacity_for(capacity);    // Calculate maxload of capacity.    uint32_t maxload = hashmap_maxload_of(capacity);    // Allocate memory for buckets.    struct hashmap_entry** buckets = (struct hashmap_entry**) malloc(capacity * sizeof(void*));    if (buckets == NULL) return -1;    // Allocate memory for entries.    struct hashmap_entry* entries = (struct hashmap_entry*) malloc(maxload * sizeof(struct hashmap_entry));    if (entries == NULL) return (free(buckets), -1);    // Set buckets and entries to 0    memset(buckets, 0, capacity * sizeof(void*));    memset(entries, 0, maxload * sizeof(struct hashmap_entry));    // Init members    map-&gt;__size     = 0;    map-&gt;__capacity = capacity;    map-&gt;__buckets  = buckets;    map-&gt;__entries  = entries;    map-&gt;__current  = entries;    map-&gt;__freelist = NULL;    map-&gt;__hash     = hash ? hash : __hashmap_default_hash;    map-&gt;__equals   = equals ? equals : __hashmap_default_equals;    return 0;&#125;int hashmap_destroy(hashmap_t* map) &#123;    if (map-&gt;__buckets) free(map-&gt;__buckets);    if (map-&gt;__entries) free(map-&gt;__entries);    memset(map, 0, sizeof(hashmap_t));    return 0;&#125;int hashmap_clear(hashmap_t* map) &#123;    uint32_t maxload = hashmap_maxload_of(map-&gt;__capacity);    map-&gt;__size      = 0;    map-&gt;__current   = map-&gt;__entries;    map-&gt;__freelist  = NULL;    // Set buckets and entries to 0    memset(map-&gt;__buckets, 0, map-&gt;__capacity * sizeof(void*));    memset(map-&gt;__entries, 0, maxload * sizeof(struct hashmap_entry));    return 0;&#125;int hashmap_resize(hashmap_t* map, uint32_t capacity) &#123;    capacity         = __hashmap_capacity_for(capacity);    uint32_t maxload = hashmap_maxload_of(capacity);    // Check capacity and maxload.    if (maxload &lt; map-&gt;__size || capacity &gt; HASHMAP_MAX_SIZE) return -1;    // Resize.    return __hashmap_resize(map, capacity);&#125;uint32_t hashmap_size(hashmap_t* map) &#123;    return map-&gt;__size;&#125;uint32_t hashmap_capacity(hashmap_t* map) &#123;    return map-&gt;__capacity;&#125;uint32_t hashmap_maxload(hashmap_t* map) &#123;    return hashmap_maxload_of(map-&gt;__capacity);&#125;#define hashmap_find_curr(MAP, CURR, HASH, KEY)                                       \\    (&#123;                                                                                \\        bool __exists = false;                                                        \\        for (; (CURR); (CURR) = (CURR)-&gt;next) &#123;                                       \\            if ((CURR)-&gt;hash == (HASH)) &#123;                                             \\                if ((__exists = hashmap_equals((MAP), (CURR)-&gt;pair.k, (KEY)) == 0)) &#123; \\                    break;                                                            \\                &#125;                                                                     \\            &#125; else if ((CURR)-&gt;hash &gt; (HASH)) &#123;                                       \\                break;                                                                \\            &#125;                                                                         \\        &#125;                                                                             \\        __exists;                                                                     \\    &#125;)#define hashmap_find_prev(MAP, PREV, CURR, HASH, KEY)                                 \\    (&#123;                                                                                \\        bool __exists = false;                                                        \\        for (; (CURR); (PREV) = (CURR), (CURR) = (CURR)-&gt;next) &#123;                      \\            if ((CURR)-&gt;hash == (HASH)) &#123;                                             \\                if ((__exists = hashmap_equals((MAP), (CURR)-&gt;pair.k, (KEY)) == 0)) &#123; \\                    break;                                                            \\                &#125;                                                                     \\            &#125; else if ((CURR)-&gt;hash &gt; (HASH)) &#123;                                       \\                break;                                                                \\            &#125;                                                                         \\        &#125;                                                                             \\        __exists;                                                                     \\    &#125;)int hashmap_insert(hashmap_t* map, void* key, void* value, bool update) &#123;    // Check size.    if (map-&gt;__size == hashmap_maxload_of(map-&gt;__capacity)) &#123;        uint32_t capacity = map-&gt;__capacity &lt;&lt; 1; // capacity × 2        // Check capacity.        if (capacity &gt; HASHMAP_MAX_SIZE) return -1;        // Try to resize.        if (__hashmap_resize(map, capacity) != 0) return -1;    &#125;    // Calculate hash and index.    uint32_t              hash = hashmap_hash(map, key);    uint32_t              buck = hashmap_index_for(hash, map-&gt;__capacity);    struct hashmap_entry *prev = NULL, *curr = map-&gt;__buckets[buck];    bool                  exists = hashmap_find_prev(map, prev, curr, hash, key);    // Try update.    if (exists) &#123;        return update ? (curr-&gt;pair.v = value, 0) : -1;    &#125;    // Select an entry.    struct hashmap_entry* entry = map-&gt;__freelist;    if (entry)        map-&gt;__freelist = entry-&gt;next;    else        entry = map-&gt;__current++;    // Set members.    entry-&gt;pair.k = key;    entry-&gt;pair.v = value;    entry-&gt;uses   = 1;    entry-&gt;hash   = hash;    entry-&gt;next   = curr;    // Insert the entry to prev or buckets.    if (prev)        prev-&gt;next = entry;    else        map-&gt;__buckets[buck] = entry;    map-&gt;__size++;    return 0;&#125;int hashmap_delete(hashmap_t* map, void* key) &#123;    // Calculate hash and index.    uint32_t              hash = hashmap_hash(map, key);    uint32_t              buck = hashmap_index_for(hash, map-&gt;__capacity);    struct hashmap_entry *prev = NULL, *curr = map-&gt;__buckets[buck];    bool                  exists = hashmap_find_prev(map, prev, curr, hash, key);    if (!exists) return -1;    // Remove the entry from prev or buckets.    if (prev)        prev-&gt;next = curr-&gt;next;    else        map-&gt;__buckets[buck] = curr-&gt;next;    // Add the entry to free list.    curr-&gt;uses      = 0;    curr-&gt;next      = map-&gt;__freelist;    map-&gt;__freelist = curr;    map-&gt;__size--;    return 0;&#125;int hashmap_set(hashmap_t* map, void* key, void* value) &#123;    uint32_t              hash   = hashmap_hash(map, key);    uint32_t              buck   = hashmap_index_for(hash, map-&gt;__capacity);    struct hashmap_entry* curr   = map-&gt;__buckets[buck];    bool                  exists = hashmap_find_curr(map, curr, hash, key);    return exists ? (curr-&gt;pair.v = value, 0) : -1;&#125;void* hashmap_get(hashmap_t* map, void* key, void* default_value) &#123;    uint32_t              hash   = hashmap_hash(map, key);    uint32_t              buck   = hashmap_index_for(hash, map-&gt;__capacity);    struct hashmap_entry* curr   = map-&gt;__buckets[buck];    bool                  exists = hashmap_find_curr(map, curr, hash, key);    return exists ? curr-&gt;pair.k : default_value;&#125;bool hashmap_exists(hashmap_t* map, void* key) &#123;    uint32_t              hash   = hashmap_hash(map, key);    uint32_t              buck   = hashmap_index_for(hash, map-&gt;__capacity);    struct hashmap_entry* curr   = map-&gt;__buckets[buck];    bool                  exists = hashmap_find_curr(map, curr, hash, key);    return exists;&#125;bool hashmap_iterator_next(struct hashmap_iterator* iter) &#123;    uint32_t maxload = hashmap_maxload_of(iter-&gt;__map-&gt;__capacity);    while (iter-&gt;__bucket_id &lt; maxload) &#123;        if (iter-&gt;__entry-&gt;uses == 0) &#123;            iter-&gt;__entry++;            iter-&gt;__bucket_id++;        &#125; else &#123;            iter-&gt;pair = &amp;iter-&gt;__entry-&gt;pair;            iter-&gt;__entry++;            iter-&gt;__bucket_id++;            return true;        &#125;    &#125;    iter-&gt;pair = NULL;    return false;&#125;\n\n3. 性能分析与优化","categories":["数据结构"],"tags":["数据结构","C语言","哈希表"]},{"title":"数据结构：跳表","url":"/2021/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/","content":"！！！（未完成）！！！\n\nSkipList(跳表)这种数据结构是由 William Pugh 于 1990 年在在 Communications of the ACM June 1990, 33(6) 668-676 发表了 Skip lists: a probabilistic alternative to balanced trees，在其中详细描述了他的工作。由论文标题可知，SkipList 的设计初衷是作为替换平衡树的一种选择。\n我们都知道，AVL 树有着严格的 O(logN)的查询效率，但是由于插入过程中可能需要多次旋转，导致插入效率较低，因而才有了在工程界更加实用的红黑树。\n但是红黑树有一个问题就是在并发环境下使用不方便，比如需要更新数据时，Skip 需要更新的部分比较少，锁的东西也更少，而红黑树有个平衡的过程，在这个过程中会涉及到较多的节点，需要锁住更多的节点，从而降低了并发性能。\nSkipList 还有一个优势就是实现简单，SkipList 的实现只花了 2 个小时，而红黑树，我可能得 2 天。\n时隔将近三十多年，SkipList 这种数据结构仍在许多途径有用武之地，比如 Redis, 还有 Google 的著名项目 Bigtable.\n一、原理其实跳表就是在普通单向链表的基础上增加了一些索引，而且这些索引是分层的，从而可以快速地查的到数据。如下是一个典型的跳表:\n1. 跳表结构2. 跳表查找3. 跳表添加4. 跳表删除二、实现1. 结构体定义#define SKIPLIST_MAX_LEVEL 16 // The maximum level of skiplist.struct skiplist_node;typedef struct skiplist {    uint32_t              __size, __level;    struct skiplist_node* __head;    compare_fn_t          __compare;} skiplist_t;struct skiplist_pair {    void* k;    void* v;};struct skiplist_node {    struct skiplist_pair  pair;\t\t\t// Ket and value pair.    uint32_t              __level; \t\t// Node level.    struct skiplist_node* __forward[]; \t// Forward list.};\n\n2. 迭代器定义struct skiplist_iterable {    const struct skiplist_pair* pair;    struct skiplist_node*       __node;};bool skiplist_iterable_next(struct skiplist_iterable*);#define skiplist_iterable_init(SKIPLIST) \\    { .pair = NULL, .__node = (SKIPLIST)-&gt;__head }#define skiplist_foreach(SKIPLIST, ITER) \\    for (struct skiplist_iterable ITER = skiplist_iterable_init(SKIPLIST); skiplist_iterable_next(&amp;ITER);)\n\n3. 函数定义#define skiplist_compare(SKIPLIST, A, B) ((SKIPLIST)-&gt;__compare(A, B))int      skiplist_init(skiplist_t*, compare_fn_t);int      skiplist_destroy(skiplist_t*);int      skiplist_clear(skiplist_t*);uint32_t skiplist_size(skiplist_t*);uint32_t skiplist_level(skiplist_t*);int      skiplist_insert(skiplist_t*, void* key, void* value, bool update);int      skiplist_remove(skiplist_t*, void* key);void*    skiplist_get(skiplist_t*, void* key, void* default_value);int      skiplist_set(skiplist_t*, void* key, void* value);bool     skiplist_exists(skiplist_t*, void* key);\n\n4. 函数实现\n随机层数rand_level：跳表的插入依赖随机层数，这里层数为的概率为。\n\nuint32_t rand_level() {    uint32_t level = 1;    while (level &lt; SKIPLIST_MAX_LEVEL &amp;&amp; rand() &lt; RAND_MAX / 2)        level++;        return level;}\n\n\n创建跳表节点alloc_node：根据level计算size以分配内存，并将其初始化。\n\nstruct skiplist_node* alloc_node(void* key, void* value, uint32_t level) {    size_t                size = sizeof(struct skiplist_node) + level * sizeof(void*);    struct skiplist_node* node = (struct skiplist_node*) malloc(size);    node-&gt;pair.k               = key;    node-&gt;pair.v               = value;    node-&gt;__level              = level;    return node;}\n\n\n初始化skiplist_init：分配初始node作为跳表的head，它的层数为SKIPLIST_MAX_LEVEL。\n\nint skiplist_init(skiplist_t* skiplist, compare_fn_t compare) {    struct skiplist_node* head = alloc_node(NULL, NULL, SKIPLIST_MAX_LEVEL);    if (head == NULL) return -1;    memset(head-&gt;__forward, 0, SKIPLIST_MAX_LEVEL * sizeof(void*));    skiplist-&gt;__size    = 0;    skiplist-&gt;__level   = 1;    skiplist-&gt;__head    = head;    skiplist-&gt;__compare = compare;    return 0;}\n\n\n销毁函数skiplist_destroy：释放所有内存，清空结构体。\n\nint skiplist_destroy(skiplist_t* skiplist) {    struct skiplist_node *curr = skiplist-&gt;__head, *next = NULL;    for (; curr; curr = next) {        next = curr-&gt;__forward[0];        free(curr);    }    memset(skiplist, 0, sizeof(skiplist_t));    return 0;}\n\n\n清空函数skiplist_clear：清空跳表需要释放除了head以外的所有node，然后将head的forward列表置空。\n\nint skiplist_clear(skiplist_t* skiplist) {    struct skiplist_node *curr = skiplist-&gt;__head-&gt;__forward[0], *next = NULL;    for (; curr; curr = next) {        next = curr-&gt;__forward[0];        free(curr);    }    memset(skiplist-&gt;__head-&gt;__forward, 0, SKIPLIST_MAX_LEVEL * sizeof(void*));    skiplist-&gt;__size  = 0;    skiplist-&gt;__level = 1;    return 0;}\n\n\n插入函数skiplist_insert：\n\nint skiplist_insert(skiplist_t* skiplist, void* key, void* value, bool update) {    struct skiplist_node* updates[SKIPLIST_MAX_LEVEL];    struct skiplist_node *prev = skiplist-&gt;__head, *curr = NULL, *tail = NULL;    for (int64_t level = skiplist-&gt;__level - 1; level &gt;= 0; --level) {        curr = prev-&gt;__forward[level];        for (; curr != tail; prev = curr, curr = curr-&gt;__forward[level]) {            int ret = skiplist_compare(skiplist, curr-&gt;pair.k, key);            if (ret &lt; 0) continue;            if (ret &gt; 0) {                tail = curr;                break;            }            return update ? (curr-&gt;pair.v = value, 0) : -1;        }        updates[level] = prev;    }    struct skiplist_node* node = alloc_node(key, value, rand_level());    if (node == NULL) return -1;    for (; skiplist-&gt;__level &lt; node-&gt;__level; skiplist-&gt;__level++) {        updates[skiplist-&gt;__level] = skiplist-&gt;__head;    }    for (uint32_t level = 0; level &lt; node-&gt;__level; level++) {        node-&gt;__forward[level]           = updates[level]-&gt;__forward[level];        updates[level]-&gt;__forward[level] = node;    }    skiplist-&gt;__size++;    return 0;}\n\n\n删除函数skiplist_remove\n\nint skiplist_remove(skiplist_t* skiplist, void* key) {    struct skiplist_node* updates[SKIPLIST_MAX_LEVEL];    struct skiplist_node *prev = skiplist-&gt;__head, *curr = NULL, *tail = NULL;    bool                  exists = false;    for (int64_t level = skiplist-&gt;__level - 1; level &gt;= 0; --level) {        curr = prev-&gt;__forward[level];        for (; curr != tail; prev = curr, curr = curr-&gt;__forward[level]) {            int ret = skiplist_compare(skiplist, curr-&gt;pair.k, key);            if (ret &lt; 0) continue;            if (ret &gt; 0) {                tail = curr;            } else {                exists = true;            }            break;        }        updates[level] = prev;    }    if (!exists) return -1;    for (uint32_t level = 0; level &lt; curr-&gt;__level; level++) {        updates[level]-&gt;__forward[level] = curr-&gt;__forward[level];    }    while (skiplist-&gt;__level &gt; 1 &amp;&amp; skiplist-&gt;__head-&gt;__forward[skiplist-&gt;__level - 1] == NULL) {        skiplist-&gt;__level--;    }    free(curr);    skiplist-&gt;__size--;    return 0;}\n\n\n查询、修改与判存函数skiplist_get、skiplist_set、skiplist_exists\n\nvoid* skiplist_get(skiplist_t* skiplist, void* key, void* default_value) {    struct skiplist_node *prev = skiplist-&gt;__head, *curr = NULL, *tail = NULL;    for (int64_t level = skiplist-&gt;__level - 1; level &gt;= 0; --level) {        curr = prev-&gt;__forward[level];        for (; curr != tail; prev = curr, curr = curr-&gt;__forward[level]) {            int ret = skiplist_compare(skiplist, curr-&gt;pair.k, key);            if (ret &lt; 0) continue;            if (ret &gt; 0) {                tail = curr;                break;            }            return curr-&gt;pair.v;        }    }    return default_value;}int skiplist_set(skiplist_t* skiplist, void* key, void* value) {    struct skiplist_node *prev = skiplist-&gt;__head, *curr = NULL, *tail = NULL;    for (int64_t level = skiplist-&gt;__level - 1; level &gt;= 0; --level) {        curr = prev-&gt;__forward[level];        for (; curr != tail; prev = curr, curr = curr-&gt;__forward[level]) {            int ret = skiplist_compare(skiplist, curr-&gt;pair.k, key);            if (ret &lt; 0) continue;            if (ret &gt; 0) {                tail = curr;                break;            }            return (curr-&gt;pair.v = value, 0);        }    }    return -1;}bool skiplist_exists(skiplist_t* skiplist, void* key) {    struct skiplist_node *prev = skiplist-&gt;__head, *curr = NULL, *tail = NULL;    for (int64_t level = skiplist-&gt;__level - 1; level &gt;= 0; --level) {        curr = prev-&gt;__forward[level];        for (; curr != tail; prev = curr, curr = curr-&gt;__forward[level]) {            int ret = skiplist_compare(skiplist, curr-&gt;pair.k, key);            if (ret &lt; 0) continue;            if (ret &gt; 0) {                tail = curr;                break;            }            return true;        }    }    return false;}\n\n\n迭代器函数skiplist_iterable_next\n\nbool skiplist_iterable_next(struct skiplist_iterable* iter) {    struct skiplist_node* next = iter-&gt;__node-&gt;__forward[0];    if (next) {        iter-&gt;__node = next;        iter-&gt;pair   = &amp;iter-&gt;__node-&gt;pair;        return true;    }    iter-&gt;pair = NULL;    return false;}\n","categories":["数据结构"],"tags":["数据结构","C语言","跳表"]},{"title":"机器学习：经典算法的极简实现","url":"/2021/11/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E7%9A%84%E6%9E%81%E7%AE%80%E5%AE%9E%E7%8E%B0/","content":"大三的时候曾花两个星期学习了几个经典的机器学习算法，学习方法主要是白天参考《统计学习方法》推导公式，晚上利用公式编写实现。在参考 GitHub 上算法实现时，我发现其中大多数都比较繁杂冗长，很难体现出算法的核心思想。因此我特地找出了以前的机器学习算法实现，在修改整理后分享给大家（Github 地址）。\n所有算法的实现都没有使用其他机器学习库。希望可以帮助大家对机器学习算法及其本质原理有个基本的了解，但并不是提供最有效的实现。\n目前已经实现的算法包括：\n\nAdaBoost\n决策树\nEM 算法\n高斯混合模型\nK-Means\nK 近邻\n线性判别分析\n逻辑斯蒂回归\n朴素贝叶斯\n主成因分析\n感知机\n支持向量机\n\n算法实现尽可能精简，因此大多数都只有几行，例如：\n\n主成因分析：\nclass PCA:    ...    def __call__(self, X: np.ndarray):        X_norm = X - X.mean(axis=0)  # 去中心化        L, V = np.linalg.eig(X_norm.T @ X_norm)  # 对协方差矩阵进行特征值分解        topk = np.argsort(L)[::-1][:self.k]  # 找出前K大特征值对应的索引        return X_norm @ V[:, topk]  # 将去中心化的X乘以前K大特征值对应的特征向量\n\nK 近邻：\nclass KNN:    ...    def __call__(self, X: np.ndarray):        Y = np.zeros([len(X)], dtype=int)  # X对应的类别        for i, x in enumerate(X):            dist = LA.norm(self.X - x, axis=1)  # 计算x与所有已知类别点的距离            topk = np.argsort(dist)[:self.k]  # 取距离最小的k个点对应的索引            Y[i] = np.bincount(self.Y[topk]).argmax()  # 取近邻点最多的类别作为x的类别        return Y\n\n感知机：\nclass Perceptron:    ...    def fit(self, X: np.ndarray, Y: np.ndarray):        for x, y in zip(pad(X), Y):            if y * (x @ self.weights) &lt;= 0:  # 分类错误, y 与 wx + b 符号不同                neg_grad = x * y  # 计算weights的负梯度                self.weights += self.lr * neg_grad  # 沿负梯度方向更新weights    def __call__(self, X: np.ndarray):        pred = pad(X) @ self.weights        return np.where(pred &gt; 0, 1, -1)\n\n逻辑斯蒂回归：\nclass LogisticRegression:    ...    def fit(self, X: np.ndarray, Y: np.ndarray):        X_pad = pad(X)  # 为X填充1作为偏置        pred = sigmoid(X_pad @ self.weights)  # 计算预测值        grad = X_pad.T @ (pred - Y) / len(pred)  # 计算梯度        self.weights -= self.lr * grad  # 沿负梯度更新参数    def __call__(self, X: np.ndarray):        pred = sigmoid(pad(X) @ self.weights)  # 计算预测值        return np.where(pred &gt; 0.5, 1, 0)  # 将(0, 1)之间分布的概率转化为&#123;0, 1&#125;标签\n\n除了最精简的实现之外，还对一些算法进行了可视化：\n\nAdaBoost\n主成因分析\n线性判别分析\n感知机\n逻辑斯蒂回归\nK-Means\n高斯混合模型\nK 近邻\n支持向量机\n\n","categories":["机器学习"],"tags":["机器学习","算法","Python"]},{"title":"图神经网络总结","url":"/2021/11/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/","content":"消息机制：$$x_i^\\prime = \\phi \\left( x_i, \\mathop{aggregate}{j \\in \\mathcal{N(i)}} \\varphi (x_i,x_j,\\theta{ij}) \\right)$$\n其中为激活函数，为融合方法，为激活函数\nGCNConv\nChebConv\nGraphSAGEConv$$\\hat x_i = \\mathop{aggregate}{j \\in \\mathcal{N}(i) \\cup {i}}(\\theta x_j)\\newlinex^\\prime_i = \\frac{\\hat x_i}{|| \\hat x_i ||{2}}$$\nGraphConv\nGATConv\nAGNNConv\nTAGConv\nGINConv\n\n其中为神经网络，比如 MLP\n\nSGConv\nAPPNP\nRGCNConv\nSignedConv\nDNAConv$$x_v^{(t)} = h_\\theta^{(t)} \\left( x^{(t)}{v \\leftarrow v}, {x^{(t)}{v \\leftarrow w} | w \\in \\mathcal{N}(v)} \\right)\\newlinex^{(t)}_{v \\leftarrow w} = \\mathop{Attention} \\left(x_v^{(t-1)} \\theta_Q^{(t)},[x_w^1,\\cdots,x_w^{(t-1)}] \\theta_K^{(t)},[x_w^1,\\cdots,x_w^{(t-1)}] \\theta_V^{(t)},\\right)$$\n\n表示的映射矩阵，表示不训练的 GCNConv\n\nPointConv\n\n表示每个点的位置\n\nGMMConv\nSplineConv\nNNConv\n\n表示神经网络，比如 MLP\n\nCGConv\n\n\n\nEdgeConv\nXConv\nR-GCN$$x_i^\\prime = \\sigma \\left( \\sum_{r \\in \\mathcal{R}} \\sum_{j \\in \\mathcal{N}^{r}{i}} \\frac{1}{c{i,r}} W_r x_j + W_0 x_i \\right)$$\n","categories":["深度学习"],"tags":["深度学习","图神经网络"]},{"title":"小想法：核注意力机制","url":"/2021/11/03/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E6%A0%B8%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/","content":"1. 线性注意力在 Transformer 中，注意力机制表示为：，，，若定义相似度量函数 ，则可令\n\n则\n\n论文《Attention is all you need》中提到了以下以下几种 ：\n\n点积：\n缩放点积：\n双线性：\n拼接：\n\n2. 非线性核注意力将点积、缩放点积、双线性、拼接统一描述为键值在内积空间的映射及其在内积空间的内积运算，即\n\n其中，为内积空间，令核函数为，即\n\n2.1. 线性注意力机制的表示对于点积模型，令，则有\n\n对于缩放点积模型，令，则有\n\n对于双线性模型，令，其中则有\n\n对于拼接模型，令：\n\n\n\n则有：\n\n2.2. 非线性注意力机制可以看出，线性核注意力机制都只对键值分量进行放缩以计算内积，本质上提取的仍是线性相关性，对于非线性相关性却无能为力。\n以高斯核为例，使用非线性核的注意力机制如下：\n\n3. 高维情况若为高维的矩阵甚至是张量，可以将核函数扩展到高维情形，已二维张量矩阵为例，可以将矩阵的分量嵌入到欧式空间来计算内积，如：\n\n即与的哈达马积的所有分量的数值和。\n4. 高斯核注意力机制的实现import torchfrom torch import nnclass KernelAttention(nn.Module):    def __init__(self):        super(KernelAttention, self).__init__()    def forward(self, k: torch.Tensor, q: torch.Tensor, v: torch.Tensor) -&gt; torch.Tensor:        attention = torch.exp(-torch.norm(k.unsqueeze(1) - q.unsqueeze(2), dim=-1))        return attention @ v\n","categories":["深度学习"],"tags":["深度学习","注意力机制","核方法"]},{"title":"线性代数：柯西-比内公式证明","url":"/2021/11/01/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E6%9F%AF%E8%A5%BF-%E6%AF%94%E5%86%85%E5%85%AC%E5%BC%8F%E8%AF%81%E6%98%8E/","content":"如何理解或是证明柯西-比内公式？ - 木亦有知的回答 - 知乎\n我曾在陈维桓《微分流形初步》第二版的第一章课后习题第 50 题看到过类似的问题，柯西比内公式其实是这个题的一个推论，证明主要利用了外代数的基本性质。\n\n\n\n\n\n","categories":["线性代数"],"tags":["线性代数","外代数","柯西-比内公式"]}]